We use Spring Framework to Instantiate beans and wire dependencies // known as Dependency Injection
Spring IoC (Inversion of Control) Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. The Container uses Dependency Injection(DI) to manage the components that make up the application.
// Inversion of control means the responsibility of creation of objects goes to the Spring framework (Mostly using the @Autowire annotation), not like the class which 
has the object creating the object

There are 2 types of IOC containers

1) Bean Factory
2) Application Context

bean factory is mostly used by low memory applications like mobile phones

The configuration for application context can be defined in 2 ways

1) @Configuration annotation
2) using configuration.xml file

@Component means this is something which Spring needs to manage

@ComponentScan is used to tell the Spring Container where to scan for packages which contain the beans

Normally in Spring we have to specify the package which needs to be scanned to figure out which packages need to be scanned for beans, although
Spring Boot makes the process of Component scan easier, it will check for @SpringBootApplication annotation , what package this annotation lies in
Spring boot will go and scan that package for the beans

Spring beans have 4 scopes

Singleton : One instance per Spring Context
prototype : New Bean whenever requested
request : 1 bean per HTTP request. Web aware Spring Application Context
session : 1 bean per HTTP session. Web aware Spring Application Context

The default scope of a bean is singleton


By default Spring beans are not Thread Safe

Types of dependency injections in Spring 

Initially Spring framework used to support configuration only via xml, but later on annotation based config was introduced


Setter Injection
Constructor injection

Whenever we get bean not found exception, these could be 2 main reasons
--> @Component Missing
--> @ComponentScan not defined properly

In component scan there might be more than 1 matching components that leads to
NoUniqueBeanException

In this case @Primary annotation helps, as it marks a bean as primary and give it preference while bean matching
@Qualifier also helps see the example below

@Component
public class ComplexAlgorithmImpl{

@Autowired
@Qualifier("main algorithm)
private SortAlgorithm sortAlgorithm;

@Component
@Qualifier("main algorithm")
public class BubbleSortAlgorithm implements SortAlgorithm

Spring has a number of Projects

Spring Web
Spring JDBC
Spring web flux
Spring Boot
Spring Cloud
Spring BATCH
Spring HATEOS
Spring Integration


